package main

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"net/http/httptest"
	"runtime/debug"

	"github.com/ethereum/go-ethereum/crypto"
	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	vaultType "github.com/vultisig/commondata/go/vultisig/vault/v1"
	"github.com/vultisig/plugin/common"
	rtypes "github.com/vultisig/recipes/types"
	vcommon "github.com/vultisig/verifier/common"
	vtypes "github.com/vultisig/verifier/types"
	"google.golang.org/protobuf/proto"
)

/*

{
  "id": "sample-fee-collection-policy-v1",
  "name": "Sample Fee Collection Policy",
  "description": "Allows collecting fees of up to 1 native ETH from Bob's address and up to 0.1 BTC from Alice's address.",
  "rules": [
    {
      "id": "allow-eth-transfer-to-bob-max-1eth",
      "description": "Allow transfer of native ETH to Bob's address (0xb0b0000000000000000000000000000000000001), up to 1 ETH.",
      "resource": "ethereum.usdc.transfer",
      "parameter_constraints": [
        {
          "parameter_name": "recipient",
          "constraint": {
            "type": "CONSTRAINT_TYPE_FIXED",
            "fixed_value": "0xb0b0000000000000000000000000000000000001",
            "required": true
          }
        },
        {
          "parameter_name": "amount",
          "constraint": {
            "type": "CONSTRAINT_TYPE_MAX",
            "max_value": "1000000000000000000",
            "denominated_in": "wei",
            "required": true
          }
        }
      ],
      "effect": "EFFECT_ALLOW"
    }
  ]
}
*/

func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("Recovered from panic:", r)
			fmt.Println("Stack trace:\n", string(debug.Stack()))
		}
	}()

	// key parts of the policy
	collectorAddress := ""
	policyId := "00000000-0000-0000-0000-000000000000"
	publicKey := ""
	privateKey := ""
	policyVersion := 1
	pluginVersion := "1.0.0"
	flag.StringVar(&collectorAddress, "collector", "", "Fee collector address (e.g., 0xCollectorAddress)")
	flag.StringVar(&policyId, "policy-id", policyId, "The ID of the policy")
	flag.StringVar(&publicKey, "public-key", publicKey, "The public key of the policy (ECDSA public key)")
	flag.IntVar(&policyVersion, "policy-version", policyVersion, "The version of the policy")
	flag.StringVar(&pluginVersion, "plugin-version", pluginVersion, "The version of the plugin")
	flag.StringVar(&privateKey, "private-key", privateKey, "The private key of the policy (eth derived private key)")

	// script helpers
	createPolicyInDb := true
	flag.BoolVar(&createPolicyInDb, "create-policy-in-db", createPolicyInDb, "Whether to create the policy in the database")

	//--collector "0x214D6fe391ca1e87A3bf3D2b0086c2D40c4c67D7" --public-key "03a1a78bb50bd7acc6f0a56778b7f6529192dbe05e85b07a828b9d0941694e2945" --private-key "b1e5c04430f79e8fce0a64d0131e20842df8e878179433b3256a616230533573"
	flag.Parse()

	transferRule := rtypes.Rule{
		Id:          "allow-usdc-transfer-to-collector",
		Description: "Allow transfer of USDC to the fee collector address.",
		Resource:    "ethereum.usdc.transfer",
		ParameterConstraints: []*rtypes.ParameterConstraint{
			&rtypes.ParameterConstraint{
				ParameterName: "recipient",
				Constraint: &rtypes.Constraint{
					Type: rtypes.ConstraintType_CONSTRAINT_TYPE_FIXED,
					Value: &rtypes.Constraint_FixedValue{
						FixedValue: collectorAddress,
					},
					Required: true,
				},
			},
			&rtypes.ParameterConstraint{
				ParameterName: "amount",
				Constraint: &rtypes.Constraint{
					Type:     rtypes.ConstraintType_CONSTRAINT_TYPE_UNSPECIFIED,
					Required: true,
				},
			},
		},
		Effect: rtypes.Effect_EFFECT_ALLOW,
	}

	recipe := rtypes.Policy{
		Id:          "sample-fee-collection-policy-v1",
		Name:        "Sample Fee Collection Policy",
		Description: "Allows collecting of fees generated by other plugins in USDC.",
		Rules: []*rtypes.Rule{
			&transferRule,
		},
	}

	policyIdUuid, err := uuid.Parse(policyId)
	if err != nil {
		log.Fatalf("Failed to parse policy ID: %v", err)
	}

	pluginPolicy, err := CreatePluginPolicy(policyIdUuid, publicKey, privateKey, recipe)
	if err != nil {
		log.Fatalf("Failed to create plugin policy: %v", err)
	}

	json, err := json.MarshalIndent(pluginPolicy, "", "  ")
	if err != nil {
		log.Fatalf("Failed to marshal plugin policy: %v", err)
	}

	fmt.Println(string(json))
	//POLICY CREATION IS DONE ABOVE HERE. BELOW HERE ARE ADDITIONAL DB/VAULT HELPERS

	server, _, _ := createDummyServer()

	if createPolicyInDb {
		// Create a mock echo context with the policy in the request body
		e := echo.New()
		req := httptest.NewRequest(http.MethodPost, "/", bytes.NewBuffer(json))
		req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		err = server.CreatePluginPolicy(c)
		if err != nil {
			panic(err)
		}
	}
}

// used only for local testing with local policy documents
func CreatePluginPolicy(id uuid.UUID, publicKey string, privateKey string, recipe rtypes.Policy) (vtypes.PluginPolicy, error) {
	recipeBase64, err := common.RecipeToBase64(recipe)
	if err != nil {
		return vtypes.PluginPolicy{}, err
	}

	pluginPolicy := vtypes.PluginPolicy{
		ID:            id,
		PluginID:      vtypes.PluginVultisigFees_feee,
		PolicyVersion: 1,
		PluginVersion: "1.0.0",
		Active:        true,
		PublicKey:     publicKey,
		Recipe:        recipeBase64,
	}

	message, err := common.PolicyToMessageHex(pluginPolicy)
	if err != nil {
		return vtypes.PluginPolicy{}, fmt.Errorf("failed to create message hex: %w", err)
	}

	// Convert private key hex to bytes
	privateKeyBytes, err := crypto.HexToECDSA(privateKey)
	if err != nil {
		return vtypes.PluginPolicy{}, fmt.Errorf("invalid private key: %w", err)
	}

	// Create Ethereum signed message hash
	msgHash := crypto.Keccak256([]byte(fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(message), message)))

	// Sign the hash
	signature, err := crypto.Sign(msgHash, privateKeyBytes)
	if err != nil {
		return vtypes.PluginPolicy{}, fmt.Errorf("failed to sign message: %w", err)
	}
	pluginPolicy.Signature = "0x" + hex.EncodeToString(signature)

	return pluginPolicy, nil
}

func DecryptVaultFromBackup(password string, vaultBackupRaw []byte) (*vaultType.Vault, []byte, error) {
	var vaultBackup vaultType.VaultContainer
	base64DecodeVaultBackup, err := base64.StdEncoding.DecodeString(string(vaultBackupRaw))
	if err != nil {
		return nil, nil, err
	}
	if err := proto.Unmarshal(base64DecodeVaultBackup, &vaultBackup); err != nil {
		return nil, nil, err
	}

	vaultRaw := []byte(vaultBackup.Vault)
	if vaultBackup.IsEncrypted {
		// decrypt the vault
		vaultBytes, err := base64.StdEncoding.DecodeString(vaultBackup.Vault)
		if err != nil {
			return nil, nil, err
		}
		vaultRaw, err = vcommon.DecryptVault(password, vaultBytes)
		if err != nil {
			return nil, nil, err
		}
	}

	var vault vaultType.Vault
	if err := proto.Unmarshal(vaultRaw, &vault); err != nil {
		return nil, nil, err
	}

	return &vault, vaultRaw, nil
}
